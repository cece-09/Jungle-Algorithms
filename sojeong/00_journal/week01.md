# WEEK-01 Algorithms

## DAY2

2023-08-11 수학~ 범위부터 메모

### [2869] 달팽이는 올라가고 싶다

나머지가 있으면 1을 더해주고, 나누어 떨어지면 더하지 않는다. 이를 나머지 여부를 체크하는 IF문 **없이** 계산해보자!

A // B = C 에서
| 경우 | (A-1) // B 결과 |
| -- | -- |
| 나머지가 있음 | C |
| 나머지가 없음 | C-1 |

따라서 모든 경우에서, (A-1) // B를 하면 IF 문 없이 목표했던 바를 연산할 수 있다. (+ 달팽이 문제에서는 A가 0이 되는 경우는 따로 예외 처리하였다)

0주차 프로젝트에서 페이징에 필요한 값을 연산하면서 사용했던 방법인데, 이 문제를 풀면서 한번 더 생각해 볼 수 있었던 것 같다 ?

```python
A, B, V = map(int, input().split())

O = A - B
# IF로 나머지 여부 체크
print((V-A) // O + ((V-A) % O != 0) + 1)

# 연산으로 해결
if V == A:
    print(1)
else:
    print((V-A-1) // O + 2)

```

---

### [1978, 9020] 소수의 판별

N보다 작은 수 k 에 대해 N % k 를 검사한다

- k 반복문의 범위를 math.sqrt(N, 2) 즉 제곱근으로 제한할 수 있다. [링크](https://freedeveloper.tistory.com/391)
- 에라토네스의 체: 케이스가 많은 경우 유용하다 ?

---

### [1914, 9663] 재귀 Recursion

[야너두 재귀할수있어..](https://velog.io/@eddy_song/you-can-solve-recursion)

[1914] 하노이 탑

[9663] N Queens

카드 놓기와 유사한 (모든 경우의 수를 탐색하는) 방법으로 풀 수 있을 것이라고 생각해서 대략 다음과 같은 방식으로 코드를 작성했다.

```python
def queen(N):
  if N이 마지막:
      카운트하고 리턴
  모든 열에 대해:
    공격 가능할 경우:
      이 열에 퀸을 놓고
      queen(N+1)
```

[공격가능여부를 체크하는 방법]

정상적으로 답을 내었으나, 계속 시간 초과가 떴다. 문제는 아래, 대각선이 아닌 경우, 즉 퀸의 공격가능여부를 판단하는 부분을 잘못 구현한 것이었다. `cols` 배열에 각 행에 놓아진 퀸 인덱스를 저장해두고, `q`행 `i`열의 공격가능여부를 판단할 때 배열을 모두 탐색한다.

```python
def attackable(i, q):
    for r, col in enumerate(cols):
        if col == None:
            continue
        if col == i:
            return True
        if abs(col-i) == abs(q-r):
            return True
    return False
```

배열을 모두 탐색하면 기본 재귀에 걸리는 N*N에 다시*N 을 하여 무려 N의 세제곱 타임이 걸리게 된다.

[공격가능여부를 미리 flag 처리하는 방법]

```python
def queen(N):
  if N이 마지막:
      카운트하고 리턴
  모든 열에 대해:
    공격 가능할 경우:
      이 열에 퀸을 놓고, 다음 행들에 대해 미리 대각선, 아래를 flag처리
      queen(N+1)
      flag 해제
```

다음으로 생각했던 것은, 2차원 배열을 놓고, N행의 퀸 위치를 선택할 때 마다 미리 퀸을 놓을 수 없는 위치를 flage처리하여 다음 반복 떄 건너뛰도록 하는 방법이다. 그러나 이 역시 flag처리 과정에서 N번 반복문을 사용하여, 세제곱 시간이 걸리는 것은 동일했다. (오히려 2차원 배열로 인해 메모리 사용량이 늘었다.)

[최종 완성 코드]

```python
# n = 보드 가로세로, 퀸의 수
# i = 현재 놓은 퀸의 수
# a = 퀸 좌표의 열 인덱스
# b = 퀸 좌표의 오른쪽 대각선 열 인덱스
# c = 퀸 좌표의 왼쪽 대각선 열 인덱스
def queens(n, i, a, b, c):
    global cnt
    if i < n:
        for j in range(n):
            if j not in a and i+j not in b and i-j not in c:
                queens(n, i+1, a+[j], b+[i+j], c+[i-j])
    else:
        cnt += 1
        return


N = int(input())
cnt = 0
queens(N, 0, [], [], [])
print(cnt)
```

- 재귀함수의 파라미터를 먼저 생각하자
- python in 은 선형탐색이 아니다

위키피디아 파이썬 코드를 보고 작성했다. 흐름 자체는 유사하나 구현에서 공격가능여부를 판단할 때 **flag 전역변수가 아니라, 파라미터로 전달되는 리스트를 통해 검사한다는 점**이 큰 차이다. 기존 알고리즘의 문제는, flag처리를 할 경우 unflag도 생각해야 한다는 것이다. 이는 곧 queen을 놓을때마다 이를 기준으로 다음 반복에서 queen을 놓을 수 있는 위치를 계산해야 하기 때문이다. 따라서 재귀함수 자체에 파라미터로 넣는다면 공격가능여부의 판단 로직이 더 간단해진다. 알고리즘을 풀 때는 1. 가급적 깔끔하게 2. 로직에만 집중하여 코드를 짜자.

한 가지 더 알게 된 점은 in 이다. python에서의 in이 막연히 선형탐색 (for문) 과 같다고 생각하여 탐색을 직접 구현하면서 더이상 탐색할 필요가 없는 예외상황을 처리해주는 것이 더 빠르다고 생각했으나, **파이썬 내부의 최적화로 인해 in의 작동이 매우 빠르다고 한다.** 실제로 실행 시간을 재어 보니 N=15인 경우 3배 이상 차이가 발생했다.
